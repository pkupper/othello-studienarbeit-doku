\begin{lstlisting}[language=Python]
%%HTML
<style>
.container { width:100% }
</style>
\end{lstlisting}

\hypertarget{implementation-der-grafischen-benutzeroberfluxe4che}{%
\section{Implementation der Grafischen
Benutzeroberfläche}\label{implementation-der-grafischen-benutzeroberfluxe4che}}

Im folgenden Abschnitt wird eine Benutzeroberfläche für das Spiel
Othello implementiert.

\hypertarget{importieren-der-externen-abhuxe4ngigkeiten}{%
\subsection{Importieren der externen
Abhängigkeiten}\label{importieren-der-externen-abhuxe4ngigkeiten}}

Die Grafische Benutzeroberfläche verwendet zur Darstellung des
Spielzustandes, zum Anzeigen weiterer Informationen sowie für die
Benutzerinteraktion die Bibliotheken \passthrough{\lstinline!ipycanvas!}
und \passthrough{\lstinline!ipywidgets!}. Diese Lassen sich direkt im
Jupyter Notebook verwenden.

Zusätzlich werden aus dem Paket \passthrough{\lstinline!math!} der
Python Standardbibliothek die Variable \passthrough{\lstinline!pi!}
sowie die Funktion \passthrough{\lstinline!floor!} benötigt.

\begin{lstlisting}[language=Python]
import ipycanvas
import ipywidgets
import math
from ipywidgets import RadioButtons, HBox, VBox, IntSlider, Label
\end{lstlisting}

\hypertarget{globale-konstanten}{%
\subsection{Globale Konstanten}\label{globale-konstanten}}

\hypertarget{canvas-initialisieren}{%
\subsection{Canvas Initialisieren}\label{canvas-initialisieren}}

\passthrough{\lstinline!SHOW\_FRONTIER!} gibt an ob in der
Visualisierung leere Felder, die an bereits gesetzte Spielsteine
angrenzen hervorgehoben werden sollen.

\passthrough{\lstinline!SHOW\_POSSIBLE\_MOVES!} gibt ob für den aktuell
ziehenden Spieler mögliche Züge visualisiert werden sollen.

\begin{lstlisting}[language=Python]
SHOW_FRONTIER = False
SHOW_POSSIBLE_MOVES = True
\end{lstlisting}

\begin{lstlisting}[language=Python]
CELL_SIZE = 60

CANVAS_SIZE = BOARD_SIZE * CELL_SIZE

canvas = ipycanvas.MultiCanvas(2, width=CANVAS_SIZE, height=CANVAS_SIZE)
canvas[0].fill_style = 'darkgreen'
canvas[0].stroke_style = 'black'
canvas[0].fill_rect(0, 0, CANVAS_SIZE, CANVAS_SIZE)
canvas[0].begin_path()
for i in range(BOARD_SIZE+1):
    pos = i * CELL_SIZE
    canvas[0].move_to(pos, 0)
    canvas[0].line_to(pos, CANVAS_SIZE)
    canvas[0].move_to(0, pos)
    canvas[0].line_to(CANVAS_SIZE, pos)
canvas[0].stroke()
\end{lstlisting}

\hypertarget{widgets-initialisieren}{%
\subsection{Widgets Initialisieren}\label{widgets-initialisieren}}

Das \passthrough{\lstinline!score\_lbl!} Widget enthält die Steinzahl
beider Spieler im aktuellen Spielzustand

\begin{lstlisting}[language=Python]
score_lbl = ipywidgets.widgets.Label()
\end{lstlisting}

Das \passthrough{\lstinline!turn\_lbl!} Widget nennt den Spieler, der
gerade am Zug ist

\begin{lstlisting}[language=Python]
turn_lbl = ipywidgets.widgets.Label()
\end{lstlisting}

Das \passthrough{\lstinline!output!} Widget macht die Ausgabe mithilfe
von \passthrough{\lstinline!print()!}, sowie die Ausgabe von
Fehlermeldungen trotz der Verwendung von IPyWidgets und IPyCanvas
möglich.

\begin{lstlisting}[language=Python]
output = ipywidgets.widgets.Output()
\end{lstlisting}

\begin{lstlisting}[language=Python]
utility_lbl = ipywidgets.widgets.Label()
\end{lstlisting}

Die Funktion \passthrough{\lstinline!display\_board!} stellt den
angegebenen Spielzustand dar, indem zunächst der Canvas aktualisiert,
und dann zusammen mit den Status-Widgets angezeigt wird.

\begin{lstlisting}[language=Python]
def display_board(state):
    update_output(state)
    display(canvas)
    display(score_lbl)
    display(turn_lbl)
    display(utility_lbl)
    display(output)
\end{lstlisting}

In der Funktion \passthrough{\lstinline!update\_output!} wird der
Spielzustand \passthrough{\lstinline!state!} auf den Canvas gezeichnet.

\begin{lstlisting}[language=Python]
def update_output(state):
    with ipycanvas.hold_canvas(canvas):
        canvas[1].clear()
        for ((x, y), val) in numpy.ndenumerate(state.board):
            if val == NONE:
                continue
            elif val == BLACK:
                canvas[1].fill_style = 'black'
            else:
                canvas[1].fill_style = 'white'
            canvas[1].fill_arc((x + 0.5) * CELL_SIZE, (y + 0.5)
                               * CELL_SIZE, CELL_SIZE / 2.2, 0, 2 * math.pi)

        if state.last_move != None:
            (x, y) = state.last_move
            canvas[1].stroke_style = 'red'
            canvas[1].line_width = 2
            canvas[1].stroke_arc((x + 0.5) * CELL_SIZE, (y + 0.5)
                               * CELL_SIZE, CELL_SIZE / 2.2, 0, 2 * math.pi)

        if SHOW_FRONTIER:
            for (x, y) in state.frontier:
                canvas[1].fill_style = 'gray'
                canvas[1].fill_arc((x + 0.5) * CELL_SIZE, (y + 0.5)
                                   * CELL_SIZE, CELL_SIZE / 6, 0, 2 * math.pi)

        if SHOW_POSSIBLE_MOVES:
            for (x, y) in get_possible_moves(state, state.turn):
                if state.turn == BLACK:
                    canvas[1].fill_style = 'black'
                else:
                    canvas[1].fill_style = 'white'
                canvas[1].fill_arc((x + 0.5) * CELL_SIZE, (y + 0.5)
                                   * CELL_SIZE, CELL_SIZE / 6, 0, 2 * math.pi)

    score_lbl.value = f'Black Player : {count_disks(state, BLACK)} White Player : {count_disks(state, WHITE)}'
    utility_lbl.value = f'Utility: Black: {utilities[BLACK]} / White: {utilities[WHITE]}'
    if state.game_over:
        turn_lbl.value = f'{get_player_string(get_winner(state))} wins'
    else:
        turn_lbl.value = f'{get_player_string(state.turn)}s Move'
\end{lstlisting}

Für den menschlichen Spieler ist es nötig festzustellen, ob dieser auf
das Spielfeld geklickt hat, dies geschieht in der callback funktion
\passthrough{\lstinline!mouse\_down!} welche die x und y Koordinaten des
Mausklicks relativ zum Canvas erhält. Auf Basis dieser Position wird,
falls möglich, ein Zug auf das angeklickte Feld gemacht. Die Funktion
wird durch den aufruf von
\passthrough{\lstinline!Canvas.on\_mouse\_down!} bei IPyCanvas als
Callback Funktion registriert.

\begin{lstlisting}[language=Python]
def mouse_down(x_px, y_px):
    if not state.game_over:
        with output:
            x = math.floor(x_px / CELL_SIZE)
            y = math.floor(y_px / CELL_SIZE)
            try:
                make_move(state, (x, y))
            except InvalidMoveException:
                print('Invalid Move')
            update_output(state)
            try:
                next_move(state)
            except KeyboardInterrupt:
                pass


canvas[1].on_mouse_down(mouse_down)
\end{lstlisting}

\hypertarget{spieleinstellungen}{%
\subsection{Spieleinstellungen}\label{spieleinstellungen}}

\begin{lstlisting}[language=Python]
def configure_settings():
    global algorithms, modes
    global black_algorithm, black_mode, black_depth
    global white_algorithm, white_mode, white_depth
    algorithms = { 'Menschlicher Spieler': None,
                   'ProbCut': probcut,
                   'AlphaBeta': alphabeta,
                   'Minimax': minimax,
                   'Zufällig': random_ai }
    modes = { 'Feste Tiefe': ai_make_move,
              'Iterative Vertiefung': ai_make_move_id,
              'Zeitbegrenzte Vertiefung': ai_make_move_id_timelimited }
    black_algorithm = RadioButtons(
        options=algorithms.keys(),
        value='Menschlicher Spieler',
        description='Schwarz:'
    )
    black_mode = RadioButtons(
        options=modes.keys(),
        value='Zeitbegrenzte Vertiefung'
    )
    black_depth = IntSlider(value = 5, min=1, max=10, description='Suchtiefe:')
    black_settings = HBox([black_algorithm, black_mode, black_depth])
    white_algorithm = RadioButtons(
        options=algorithms.keys(),
        value='ProbCut',
        description='Weiß:'
    )
    white_mode = RadioButtons(
        options=modes.keys(),
        value='Zeitbegrenzte Vertiefung'
    )
    white_depth = IntSlider(value = 5, min=1, max=10, description='Suchtiefe:')
    white_settings = HBox([white_algorithm, white_mode, white_depth])
    display(ipywidgets.VBox([black_settings, white_settings]))
\end{lstlisting}

\begin{lstlisting}[language=Python]
def get_settings():
    return { BLACK: { 'heuristic': combined_heuristic,
                      'algorithm': algorithms[black_algorithm.value],
                      'depth': black_depth.value,
                      'mode': modes[black_mode.value] },
             WHITE: { 'heuristic': combined_heuristic,
                      'algorithm': algorithms[white_algorithm.value],
                      'depth': white_depth.value,
                      'mode': modes[white_mode.value] }}
\end{lstlisting}
