\begin{lstlisting}[language=Python]
%%HTML
<style>
.container { width:100% }
</style>
\end{lstlisting}

\hypertarget{implementation-der-grafischen-benutzeroberfluxe4che}{%
\section{Implementation der Grafischen
Benutzeroberfläche}\label{implementation-der-grafischen-benutzeroberfluxe4che}}

Im folgenden Abschnitt wird eine Benutzeroberfläche für das Spiel
Othello implementiert.

\hypertarget{importieren-der-externen-abhuxe4ngigkeiten}{%
\subsection{Importieren der externen
Abhängigkeiten}\label{importieren-der-externen-abhuxe4ngigkeiten}}

Die Grafische Benutzeroberfläche verwendet zur Darstellung des
Spielzustandes, zum Anzeigen weiterer Informationen sowie für die
Benutzerinteraktion die Bibliotheken \passthrough{\lstinline!ipycanvas!}
und \passthrough{\lstinline!ipywidgets!}. Diese Lassen sich direkt im
Jupyter Notebook verwenden.

Zusätzlich werden aus dem Paket \passthrough{\lstinline!math!} der
Python Standardbibliothek die Variable \passthrough{\lstinline!pi!}
sowie die Funktion \passthrough{\lstinline!floor!} benötigt.

\begin{lstlisting}[language=Python]
import ipycanvas
import ipywidgets
import math
\end{lstlisting}

\hypertarget{globale-konstanten}{%
\subsection{Globale Konstanten}\label{globale-konstanten}}

\hypertarget{canvas-initialisieren}{%
\subsection{Canvas Initialisieren}\label{canvas-initialisieren}}

\passthrough{\lstinline!SHOW\_FRONTIER!} gibt an ob in der
Visualisierung leere Felder, die an bereits gesetzte Spielsteine
angrenzen hervorgehoben werden sollen.

\passthrough{\lstinline!SHOW\_POSSIBLE\_MOVES!} gibt ob für den aktuell
ziehenden Spieler mögliche Züge visualisiert werden sollen.

\begin{lstlisting}[language=Python]
SHOW_FRONTIER = False
SHOW_POSSIBLE_MOVES = True
\end{lstlisting}

\begin{lstlisting}[language=Python]
CELL_SIZE = 60

CANVAS_SIZE = BOARD_SIZE * CELL_SIZE

canvas = ipycanvas.MultiCanvas(2, width=CANVAS_SIZE, height=CANVAS_SIZE)
canvas[0].fill_style = 'darkgreen'
canvas[0].stroke_style = 'black'
canvas[0].fill_rect(0, 0, CANVAS_SIZE, CANVAS_SIZE)
canvas[0].begin_path()
for i in range(BOARD_SIZE+1):
    pos = i * CELL_SIZE
    canvas[0].move_to(pos, 0)
    canvas[0].line_to(pos, CANVAS_SIZE)
    canvas[0].move_to(0, pos)
    canvas[0].line_to(CANVAS_SIZE, pos)
canvas[0].stroke()
\end{lstlisting}

\hypertarget{widgets-initialisieren}{%
\subsection{Widgets Initialisieren}\label{widgets-initialisieren}}

Das \passthrough{\lstinline!score\_lbl!} Widget enthält die Steinzahl
beider Spieler im aktuellen Spielzustand

\begin{lstlisting}[language=Python]
score_lbl = ipywidgets.widgets.Label()
\end{lstlisting}

Das \passthrough{\lstinline!turn\_lbl!} Widget nennt den Spieler, der
gerade am Zug ist

\begin{lstlisting}[language=Python]
turn_lbl = ipywidgets.widgets.Label()
\end{lstlisting}

Das \passthrough{\lstinline!output!} Widget macht die Ausgabe mithilfe
von \passthrough{\lstinline!print()!}, sowie die Ausgabe von
Fehlermeldungen trotz der Verwendung von IPyWidgets und IPyCanvas
möglich.

\begin{lstlisting}[language=Python]
output = ipywidgets.widgets.Output()
\end{lstlisting}

Die Funktion \passthrough{\lstinline!display\_board!} stellt den
angegebenen Spielzustand dar, indem zunächst der Canvas aktualisiert,
und dann zusammen mit den Status-Widgets angezeigt wird.

\begin{lstlisting}[language=Python]
def display_board(state):
    update_output(state)
    display(canvas)
    display(score_lbl)
    display(turn_lbl)
    display(output)
\end{lstlisting}

In der Funktion \passthrough{\lstinline!update\_output!} wird der
Spielzustand \passthrough{\lstinline!state!} auf den Canvas gezeichnet.

\begin{lstlisting}[language=Python]
def update_output(state):
    with ipycanvas.hold_canvas(canvas):
        canvas[1].clear()
        for ((x, y), val) in numpy.ndenumerate(state.board):
            if val == NONE:
                continue
            elif val == BLACK:
                canvas[1].fill_style = 'black'
            else:
                canvas[1].fill_style = 'white'
            canvas[1].fill_arc((x + 0.5) * CELL_SIZE, (y + 0.5) * CELL_SIZE, CELL_SIZE / 2.2, 0, 2 * math.pi)
            
        if SHOW_FRONTIER:
            for (x, y) in state.frontier:
                canvas[1].fill_style = 'gray'
                canvas[1].fill_arc((x + 0.5) * CELL_SIZE, (y + 0.5) * CELL_SIZE, CELL_SIZE / 6, 0, 2 * math.pi)
        
        if SHOW_POSSIBLE_MOVES:
            for (x, y) in get_possible_moves(state, state.turn):
                if state.turn == BLACK:
                    canvas[1].fill_style = 'black'
                else:
                    canvas[1].fill_style = 'white'
                canvas[1].fill_arc((x + 0.5) * CELL_SIZE, (y + 0.5) * CELL_SIZE, CELL_SIZE / 6, 0, 2 * math.pi)
            
    score_lbl.value = f'Black Player : {count_disks(state, BLACK)} White Player : {count_disks(state, WHITE)}'
    if state.game_over:
        turn_lbl.value = f'{get_player_string(get_winner(state))} wins'
    else:
        turn_lbl.value = f'{get_player_string(state.turn)}s Move'
\end{lstlisting}

Für den menschlichen Spieler ist es nötig festzustellen, ob dieser auf
das Spielfeld geklickt hat, dies geschieht in der callback funktion
\passthrough{\lstinline!mouse\_down!} welche die x und y Koordinaten des
Mausklicks relativ zum Canvas erhält. Auf Basis dieser Position wird,
falls möglich, ein Zug auf das angeklickte Feld gemacht. Die Funktion
wird durch den aufruf von
\passthrough{\lstinline!Canvas.on\_mouse\_down!} bei IPyCanvas als
Callback Funktion registriert.

\begin{lstlisting}[language=Python]
def mouse_down(x_px, y_px):
    if not state.game_over:
        with output:
            x = math.floor(x_px / CELL_SIZE)
            y = math.floor(y_px / CELL_SIZE)
            try:
                make_move(state, x, y)
            except InvalidMoveException:
                print('Invalid Move')
            update_output(state)
            next_move(state)

canvas[1].on_mouse_down(mouse_down)
\end{lstlisting}
