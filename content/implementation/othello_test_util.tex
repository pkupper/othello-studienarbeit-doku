\begin{lstlisting}[language=Python]
%%HTML
<style>
.container { width:100% }
</style>
\end{lstlisting}

\begin{lstlisting}[language=Python]
%run othello_game.ipynb
%run othello_ai.ipynb
\end{lstlisting}

\begin{lstlisting}[language=Python]
import time
\end{lstlisting}

\hypertarget{hilfsfunktionen}{%
\section{Hilfsfunktionen}\label{hilfsfunktionen}}

Der folgende Code beinhaltet Hilfsfunktionen zum Testen und sammeln von
Statistiken.

Die Funktion \passthrough{\lstinline!debug\_num\_visited\_states!}
berechnet für einen Spielzustand den nächsten Zug mit verschiedenen
Algorithmen und misst dabei die benötigte Zeit. Zusätzlich werden mit
den globalen Variablen \passthrough{\lstinline!debug\_mm\_count!} und
\passthrough{\lstinline!debug\_ab\_count!} die Anzahl der überprüften
Zustände gezählt. Diese Zahlen geben einen Überblick darüber, wie viele
Zweige durch den Algorithmus ausgeschlossen werden konnten und nicht
überprüft werden mussten.

\begin{lstlisting}[language=Python]
def debug_num_visited_states(state, depth):
    global transposition_table
    global debug_mm_count
    global debug_ab_count
    global debug_pc_count

    # calculate next move with each algorithm and measure time
    debug_mm_count= 0
    start = time.time()
    ai_make_move(minimax, copy.deepcopy(state), depth, combined_heuristic)
    secs = time.time() - start
    print("Minimax takes", secs, "seconds and checks", debug_mm_count, "substates")
    debug_ab_count= 0
    transposition_table = {}
    start = time.time()
    ai_make_move(alphabeta, copy.deepcopy(state), depth, combined_heuristic)
    secs = time.time() - start
    print("AlphaBeta takes", secs, "seconds and checks", debug_ab_count, "substates")
    debug_ab_count = 0
    transposition_table = {}
    start = time.time()
    ai_make_move_id(alphabeta, copy.deepcopy(state), depth, combined_heuristic)
    secs = time.time() - start
    print("AlphaBeta with iterative deepening takes", secs,
          "seconds and checks", debug_ab_count, "substates")
    debug_pc_count = 0
    transposition_table = {}
    start = time.time()
    ai_make_move(probcut, copy.deepcopy(state), depth, combined_heuristic)
    secs = time.time() - start
    print("ProbCut takes", secs, "seconds and checks",
          debug_pc_count, "substates")
\end{lstlisting}

Die Funktion \passthrough{\lstinline!get\_statistics!} ist dazu da,
mehrere Spiele zu berechnen, in denen zwei KIs gegeneinander spielen und
Statistiken darüber zu sammeln. \passthrough{\lstinline!num!} ist die
Anzahl der Spiele, die durchgeführt werden sollen. Die weiteren
Parameter legen fest, welche KIs und welche Heuristiken für die Spieler
verwendet werden sollen. Statistiken werden nach jedem Spiel
aktualisiert.

Da das Spielfeld nicht gezeichnet werden soll, wird statt
\passthrough{\lstinline!next\_move!} die Funktion
\passthrough{\lstinline!next\_move\_blind!} verwendet.

\begin{lstlisting}[language=Python]
def next_move_blind(state, settings):
    settings[state.turn]['mode'](settings[state.turn]['algorithm'], state, settings[state.turn]['depth'], settings[state.turn]['heuristic'])
    if not state.game_over:
        next_move_blind(state, settings)
\end{lstlisting}

\begin{lstlisting}[language=Python]
def play_game(settings):
    state = GameState()
    next_move_blind(state, settings)
    return count_disks(state, BLACK), count_disks(state, WHITE)
\end{lstlisting}

\begin{lstlisting}[language=Python]
import ipywidgets


def get_statistics(num, settings):
    status = ipywidgets.widgets.Label()
    display(status)
    result = []
    wins = [0, 0, 0]
    status.value = f'0 / {num} games played, b/d/w: {wins[0]}/{wins[1]}/{wins[2]}'
    try:
        for i in range(num):
            (b, w) = play_game(settings)
            result.append((b, w))
            if b > w:
                wins[0] += 1
            elif w == b:
                wins[1] += 1
            else:
                wins[2] += 1
            status.value = f'{i+1} / {num} games played, b/d/w: {wins[0]}/{wins[1]}/{wins[2]}'
    except KeyboardInterrupt:
        status.value = f'Interrupted: {i} / {num} games played, b/d/w: {wins[0]}/{wins[1]}/{wins[2]}'
    print(result)
    return wins
\end{lstlisting}
