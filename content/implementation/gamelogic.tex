\hypertarget{implementation-der-spiellogik}{%
\section{Implementation der
Spiellogik}\label{implementation-der-spiellogik}}

Im folgenden ist das Spiel Othello implementiert. Ausgangspunkt für
diese Implementierung ist Das Python Gui für Othello von Kevan Nguyen,
welches unter \url{https://github.com/kevannguyen/Othello} verfügbar
ist.

\hypertarget{abhuxe4ngigkeiten-importieren}{%
\subsection{Abhängigkeiten
Importieren}\label{abhuxe4ngigkeiten-importieren}}

\begin{lstlisting}[language=Python]
import ipycanvas
import ipywidgets
import numpy
import math
\end{lstlisting}

\hypertarget{globale-konstanten}{%
\subsection{Globale Konstanten}\label{globale-konstanten}}

\begin{lstlisting}[language=Python]
BOARD_SIZE = 8

BLACK = -1 # MINIMIZING PLAYER
NONE = 0
WHITE = 1 # MAXIMIZING PLAYER

SHOW_FRONTIER = False
SHOW_POSSIBLE_MOVES = True
\end{lstlisting}

\hypertarget{game-state}{%
\subsection{Game State}\label{game-state}}

Die Klasse GameState repäsentiert den Spielzustand. Dieser besteht aus
dem Spielfeld \passthrough{\lstinline!board!}, welches durch einen Numpy
Array repräsentiert wird, sowie dem Spieler
\passthrough{\lstinline!turn!}, der am Zug ist. Zusätzlich werden
weitere Informationen wie, mögliche Züge, Frontier und Anzahl an
Spielsteinen gehalten, um zu vermeiden, dass diese häufig neu berechnet
werden müssen.

\begin{lstlisting}[language=Python]
class GameState:
    def __init__(self):
        self.board = numpy.zeros((BOARD_SIZE, BOARD_SIZE), dtype=numpy.int8)
        self.board[3, 3] = WHITE
        self.board[3, 4] = BLACK
        self.board[4, 3] = BLACK
        self.board[4, 4] = WHITE
        self.frontier = {(2,2),(2,3),(2,4),(2,5),
                         (3,2),(3,5),(4,2),(4,5),
                         (5,2),(5,3),(5,4),(5,5)}
        self.turn = BLACK
        self.num_pieces = 4
        self.game_over = False
        self.possible_moves = [(2, 3), (3, 2), (4, 5), (5, 4)]
    def __lt__(self, other):
        return True
\end{lstlisting}

\begin{lstlisting}[language=Python]
directions = {(-1,-1),(0,-1),(1,-1),(-1,0),(1,0),(-1,1),(0,1),(1,1)}
\end{lstlisting}

Erhält die Funktion \passthrough{\lstinline!make\_move!} ein ungültigen
Spielzug, so wird eine \passthrough{\lstinline!InvalidMoveException!}
ausgelöst.

\begin{lstlisting}[language=Python]
class InvalidMoveException(Exception):
    pass
\end{lstlisting}

\passthrough{\lstinline!make\_move!} führt im Spielzustand
\passthrough{\lstinline!state!} falls möglich einen Zug auf die
Koordinaten \passthrough{\lstinline!row!} und
\passthrough{\lstinline!col!} aus.

\begin{lstlisting}[language=Python]
def make_move(state, row, col):
    if (row, col) not in state.frontier:
        print("(", row, ", ", col, ") not in Frontier")
        raise InvalidMoveException
    next_turn = state.turn
        
    possible_directions = adjacent_opposite_color_directions(state, row, col, state.turn)
    for (row_dir, col_dir) in possible_directions:
        if is_valid_directional_move(state, row, col, row_dir, col_dir, state.turn):
            next_turn = -state.turn
            convert_adjacent_cells_in_direction(state, row, col, row_dir, col_dir, state.turn)

    if next_turn != state.turn:
        state.num_pieces += 1
        state.board[(row, col)] = state.turn
        update_frontier(state, row, col)
        if can_move(state, next_turn):
            state.turn = next_turn
        elif not can_move(state, state.turn):
                state.game_over = True
                return state
        state.possible_moves = get_possible_moves(state, state.turn)
    else:
        raise InvalidMoveException()
    return state
\end{lstlisting}

Diese Funktion überprüft für einen gegebenen Zustand
\passthrough{\lstinline!state!} ob ein Zug auf die angegebenen
Koordinaten \passthrough{\lstinline!row!} und
\passthrough{\lstinline!col!} für den Spieler
\passthrough{\lstinline!turn!} möglich ist. Das Ergebnis wird als
Wahrheitswert zurückgegeben.

\begin{lstlisting}[language=Python]
def is_move_valid(state, row, col, turn):
    dirs = [(-1,-1),(0,-1),(1,-1),(-1,0),(1,0),(-1,1),(0,1),(1,1)]
    for rowdelta, coldelta in dirs:
        try:
            if state.board[row + rowdelta, col + coldelta] == -turn and is_valid_directional_move(state, row, col, rowdelta, coldelta, turn):
                return True
        except IndexError:
            continue
    return False
\end{lstlisting}

\passthrough{\lstinline!get\_winner!} bestimmt für einen Endzustand den
Gewinner des Spiels. Gewinnt Weiß, so wird der Wert 1 zurückgegeben.
Gewinnt Schwarz, wird der Wert -1 zurückgegeben. Bei einem Unentschieden
wird der Wert 0 zurückgegeben.

\begin{lstlisting}[language=Python]
def get_winner(state):
    black_disks = count_disks(state, BLACK)
    white_disks = count_disks(state, WHITE)
    if black_disks > white_disks:
        return BLACK
    if white_disks > black_disks:
        return WHITE
    else:
        return NONE
\end{lstlisting}

Die Funktion \passthrough{\lstinline!get\_possible\_moves!} bestimmt für
einen Spielzustand \passthrough{\lstinline!state!} und den Spieler
\passthrough{\lstinline!player!} die Möglichen Züge, die der Spieler
machen kann. Die Züge werden als Liste von Koordinaten zurückgegeben.

\begin{lstlisting}[language=Python]
def get_possible_moves(state, player):
    possible_moves = []
    for (row, col) in state.frontier:
            if is_move_valid(state, row, col, player):
                possible_moves.append((row, col))
    return possible_moves
\end{lstlisting}

\passthrough{\lstinline!can\_move!} überprüft ob der Spieler
\passthrough{\lstinline!player!} im Spielzustand
\passthrough{\lstinline!state!} einen Zug machen kann und gibt das
Resultat als Wahrheitswert zurück.

\begin{lstlisting}[language=Python]
def can_move(state, player):
    return len(get_possible_moves(state, player)) != 0
\end{lstlisting}

\passthrough{\lstinline!adjacent\_opposite\_color\_directions!}
betrachtet die 8 an die gegebenen Koordinaten angrenzenden Felder. Alle
Felder die einen für den Spieler \passthrough{\lstinline!turn!}
gegnerischen Stein enthalten werden als Liste von Koordinaten
zurückgegeben.

\begin{lstlisting}[language=Python]
def adjacent_opposite_color_directions(state, row, col, turn):
    dir_list = []
    for rowdelta in range(-1, 2):
        if not 0 <= row+rowdelta < 8:
            continue
        for coldelta in range(-1, 2):
            if not 0 <= col+coldelta < 8:
                continue
            if state.board[row + rowdelta, col + coldelta] == -turn:
                dir_list.append((rowdelta, coldelta))
    return dir_list
\end{lstlisting}

Überprüft ob beim setzen eines Steins des Spielers
\passthrough{\lstinline!turn!} in das durch
\passthrough{\lstinline!row!} und \passthrough{\lstinline!col!} gegebene
Feld in die durch \passthrough{\lstinline!rowdelta!} und
\passthrough{\lstinline!coldelta!} gegebene Richtung, nach den Regeln
des Spiels Othello gegnerische Steine umgedreht werden Können.

\begin{lstlisting}[language=Python]
def is_valid_directional_move(state, row, col, rowdelta, coldelta, player):
        current_row = row + rowdelta
        current_col = col + coldelta

        last_cell_color = -player

        while True:
            if not (0 <= current_row < 8 and 0 <= current_col < 8):
                break
            if state.board[current_row, current_col] == NONE:
                break           
            if state.board[current_row, current_col] == player:
                last_cell_color = player
                break

            current_row += rowdelta
            current_col += coldelta
            
        return last_cell_color == player
\end{lstlisting}

Diese Funktion dreht im Spielzustand \passthrough{\lstinline!state!}
ausgehend von dem durch \passthrough{\lstinline!row!} und
\passthrough{\lstinline!col!} gegebenen Feld die für den Spieler
\passthrough{\lstinline!player!} generischen Steine in die durch
\passthrough{\lstinline!rowdelta!} und
\passthrough{\lstinline!coldelta!} gegebene Richtung um.

\begin{lstlisting}[language=Python]
def convert_adjacent_cells_in_direction(state, row, col, rowdelta, coldelta, player):
    ''' If it can, converts all the adjacent/contiguous cells on a turn in
        a given direction until it finally reaches the specified cell's original color '''
    if is_valid_directional_move(state, row, col, rowdelta, coldelta, player):
        current_row = row + rowdelta
        current_col = col + coldelta
        
        while state.board[current_row, current_col] == -player:
            state.board[(current_row, current_col)] = player
            current_row += rowdelta
            current_col += coldelta
\end{lstlisting}

\passthrough{\lstinline!update\_frontier!} wird nach jedem Zug
aufgerufen um die Menge Frontier zu aktualisieren. Die durch
\passthrough{\lstinline!row!} und \passthrough{\lstinline!col!} Gegebene
Koordinate wird entfernt, während die Koordinaten von leeren umliegenden
Feldern hinzugefügt werden.

\begin{lstlisting}[language=Python]
def update_frontier(state, row, col):
        for current_row in range(row-1, row+2):
            if not 0 <= current_row < 8:
                continue
            for current_col in range(col-1, col+2):
                if not 0 <= current_col < 8:
                    continue
                if state.board[current_row, current_col] == NONE:
                    state.frontier.add((current_row, current_col))
        state.frontier.remove((row, col))
\end{lstlisting}

Die Funktion \passthrough{\lstinline!count\_disks!} zählt die Steine,
die der Spieler \passthrough{\lstinline!player!} im Spielzustand
\passthrough{\lstinline!state!} auf dem Spielfeld hat

\begin{lstlisting}[language=Python]
def count_disks(state, player):
    return numpy.count_nonzero(state.board == player)
\end{lstlisting}

\passthrough{\lstinline!get\_player\_string!} konvertiert die ID des
Spielers \passthrough{\lstinline!player!} in dessen Name. Ist
\passthrough{\lstinline!player == NONE!} so wird `Nobody' zurückgegeben.

\begin{lstlisting}[language=Python]
def get_player_string(player):
    return {BLACK: 'Black', WHITE: 'White', NONE: 'Nobody'}[player]
\end{lstlisting}

\hypertarget{implementation-der-grafischen-benutzeroberfluxe4che}{%
\section{Implementation der Grafischen
Benutzeroberfläche}\label{implementation-der-grafischen-benutzeroberfluxe4che}}

\hypertarget{canvas-initialisieren}{%
\subsection{Canvas Initialisieren}\label{canvas-initialisieren}}

\begin{lstlisting}[language=Python]
CELL_SIZE = 70

CANVAS_SIZE = BOARD_SIZE * CELL_SIZE

canvas = ipycanvas.MultiCanvas(2, width=CANVAS_SIZE, height=CANVAS_SIZE)
canvas[0].fill_style = 'darkgreen'
canvas[0].stroke_style = 'black'
canvas[0].fill_rect(0, 0, CANVAS_SIZE, CANVAS_SIZE)
canvas[0].begin_path()
for i in range(BOARD_SIZE+1):
    pos = i * CELL_SIZE
    canvas[0].move_to(pos, 0)
    canvas[0].line_to(pos, CANVAS_SIZE)
    canvas[0].move_to(0, pos)
    canvas[0].line_to(CANVAS_SIZE, pos)
canvas[0].stroke()
\end{lstlisting}

\hypertarget{widgets-initialisieren}{%
\subsection{Widgets Initialisieren}\label{widgets-initialisieren}}

Das \passthrough{\lstinline!score\_lbl!} Widget enthält die Steinzahl
beider Spieler im aktuellen Spielzustand

\begin{lstlisting}[language=Python]
score_lbl = ipywidgets.widgets.Label()
\end{lstlisting}

Das \passthrough{\lstinline!turn\_lbl!} Widget nennt den Spieler, der
gerade am Zug ist

\begin{lstlisting}[language=Python]
turn_lbl = ipywidgets.widgets.Label()
\end{lstlisting}

Das \passthrough{\lstinline!output!} Widget macht die Ausgabe mithilfe
von \passthrough{\lstinline!print()!}, sowie die Ausgabe von
Fehlermeldungen trotz der Verwendung von IPyWidgets und IPyCanvas
möglich.

\begin{lstlisting}[language=Python]
output = ipywidgets.widgets.Output()
\end{lstlisting}

Die Funktion \passthrough{\lstinline!display\_board!} stellt den
angegebenen Spielzustand dar, indem zunächst der Canvas aktualisiert,
und dann zusammen mit den Status-Widgets angezeigt wird.

\begin{lstlisting}[language=Python]
def display_board(state):
    update_output(state)
    display(canvas)
    display(score_lbl)
    display(turn_lbl)
    display(output)
\end{lstlisting}

In der Funktion \passthrough{\lstinline!update\_output!} wird der
Spielzustand \passthrough{\lstinline!state!} auf den Canvas gezeichnet.

\begin{lstlisting}[language=Python]
def update_output(state):
    with ipycanvas.hold_canvas(canvas):
        canvas[1].clear()
        for ((x, y), val) in numpy.ndenumerate(state.board):
            if val == NONE:
                continue
            elif val == BLACK:
                canvas[1].fill_style = 'black'
            else:
                canvas[1].fill_style = 'white'
            canvas[1].fill_arc((x + 0.5) * CELL_SIZE, (y + 0.5) * CELL_SIZE, CELL_SIZE / 2.2, 0, 2 * math.pi)
            
        if SHOW_FRONTIER:
            for (x, y) in state.frontier:
                canvas[1].fill_style = 'gray'
                canvas[1].fill_arc((x + 0.5) * CELL_SIZE, (y + 0.5) * CELL_SIZE, CELL_SIZE / 6, 0, 2 * math.pi)
        
        if SHOW_POSSIBLE_MOVES:
            for (x, y) in get_possible_moves(state, state.turn):
                if state.turn == BLACK:
                    canvas[1].fill_style = 'black'
                else:
                    canvas[1].fill_style = 'white'
                canvas[1].fill_arc((x + 0.5) * CELL_SIZE, (y + 0.5) * CELL_SIZE, CELL_SIZE / 6, 0, 2 * math.pi)
            
    score_lbl.value = f'Black Player : {count_disks(state, BLACK)} White Player : {count_disks(state, WHITE)}'
    if state.game_over:
        turn_lbl.value = f'{get_player_string(get_winner(state))} wins'
    else:
        turn_lbl.value = f'{get_player_string(state.turn)}s Move'
\end{lstlisting}

Für den menschlichen Spieler ist es nötig festzustellen, ob dieser auf
das Spielfeld geklickt hat, dies geschieht in der callback funktion
\passthrough{\lstinline!mouse\_down!} welche die x und y Koordinaten des
Mausklicks relativ zum Canvas erhält. Auf Basis dieser Position wird,
falls möglich, ein Zug auf das angeklickte Feld gemacht. Die Funktion
wird durch den aufruf von
\passthrough{\lstinline!Canvas.on\_mouse\_down!} bei IPyCanvas als
Callback Funktion registriert.

\begin{lstlisting}[language=Python]
def mouse_down(x_px, y_px):
    if not state.game_over:
        with output:
            x = math.floor(x_px / CELL_SIZE)
            y = math.floor(y_px / CELL_SIZE)
            try:
                make_move(state, x, y)
            except InvalidMoveException:
                print('Invalid Move')
            update_output(state)
            next_move(state)

canvas[1].on_mouse_down(mouse_down)
\end{lstlisting}

\begin{lstlisting}[language=Python]
#state = GameState()
\end{lstlisting}

\begin{lstlisting}[language=Python]
#display_board(state)
\end{lstlisting}

\begin{lstlisting}[language=Python]
\end{lstlisting}
