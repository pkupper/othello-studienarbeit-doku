\begin{lstlisting}[language=Python]
%%HTML
<style>
.container { width:100% }
</style>
\end{lstlisting}

\hypertarget{implementation-der-spiellogik}{%
\section{Implementation der
Spiellogik}\label{implementation-der-spiellogik}}

Im Folgenden ist das Spiel Othello implementiert. Ausgangspunkt für
diese Implementierung ist Das Python Gui für Othello von Kevan Nguyen,
welches unter \url{https://github.com/kevannguyen/Othello} verfügbar
ist.

\hypertarget{importieren-der-externen-abhuxe4ngigkeiten}{%
\subsection{Importieren der externen
Abhängigkeiten}\label{importieren-der-externen-abhuxe4ngigkeiten}}

Die Implementation stützt sich für bessere Performanz auf die Python,
Bibliothek \passthrough{\lstinline!numpy!} welche unter anderem homogene
Felder und Matrizen implementiert.

\begin{lstlisting}[language=Python]
import numpy
\end{lstlisting}

\hypertarget{globale-konstanten}{%
\subsection{Globale Konstanten}\label{globale-konstanten}}

\passthrough{\lstinline!BOARD\_SIZE!} gibt die Anzahl an Zeilen und
Spalten des quadratischen Spielfelds an.

Die Konstanten \passthrough{\lstinline!BLACK!},
\passthrough{\lstinline!WHITE!} und \passthrough{\lstinline!NONE!}
werden auf die Zahlenwerte -1 , 1 und 0 abgebildet und werden für
mehrere Zwecke genutzt: - zur Repräsentation des Spielbretts - zur
Identifikation eines Spielers - zur Berechnung der Heuristiken.

\begin{lstlisting}[language=Python]
BOARD_SIZE = 8

BLACK = -1 # MINIMIZING PLAYER
WHITE = 1 # MAXIMIZING PLAYER
NONE = 0
\end{lstlisting}

\hypertarget{game-state}{%
\subsection{Game State}\label{game-state}}

Die Klasse GameState repäsentiert den Spielzustand. Dieser besteht aus
dem Spielfeld \passthrough{\lstinline!board!}, welches durch einen Numpy
Array repräsentiert wird, sowie dem Spieler
\passthrough{\lstinline!turn!}, der am Zug ist. Zusätzlich werden
weitere Informationen wie, mögliche Züge, Frontier und Anzahl an
Spielsteinen gehalten, um zu vermeiden, dass diese häufig neu berechnet
werden müssen.

\begin{lstlisting}[language=Python]
class GameState:
    def __init__(self):
        self.board = numpy.zeros((BOARD_SIZE, BOARD_SIZE), dtype=numpy.int8)
        self.board[3, 3] = WHITE
        self.board[3, 4] = BLACK
        self.board[4, 3] = BLACK
        self.board[4, 4] = WHITE
        self.frontier = {(2,2),(2,3),(2,4),(2,5),
                         (3,2),(3,5),(4,2),(4,5),
                         (5,2),(5,3),(5,4),(5,5)}
        self.turn = BLACK
        self.num_pieces = 4
        self.game_over = False
        self.possible_moves = [(2, 3), (3, 2), (4, 5), (5, 4)]
    def __lt__(self, other):
        return True
\end{lstlisting}

\begin{lstlisting}[language=Python]
directions = {(-1,-1),(0,-1),(1,-1),(-1,0),(1,0),(-1,1),(0,1),(1,1)}
\end{lstlisting}

Erhält die Funktion \passthrough{\lstinline!make\_move!} ein ungültigen
Spielzug, so wird eine \passthrough{\lstinline!InvalidMoveException!}
ausgelöst.

\begin{lstlisting}[language=Python]
class InvalidMoveException(Exception):
    pass
\end{lstlisting}

\passthrough{\lstinline!make\_move!} führt im Spielzustand
\passthrough{\lstinline!state!} falls möglich einen Zug auf die
Koordinaten \passthrough{\lstinline!row!} und
\passthrough{\lstinline!col!} aus.

\begin{lstlisting}[language=Python]
def make_move(state, row, col):
    if (row, col) not in state.frontier:
        print("(", row, ", ", col, ") not in Frontier")
        raise InvalidMoveException
    next_turn = state.turn
        
    possible_directions = adjacent_opposite_color_directions(state, row, col, state.turn)
    for (row_dir, col_dir) in possible_directions:
        if is_valid_directional_move(state, row, col, row_dir, col_dir, state.turn):
            next_turn = -state.turn
            convert_adjacent_cells_in_direction(state, row, col, row_dir, col_dir, state.turn)

    if next_turn != state.turn:
        state.num_pieces += 1
        state.board[(row, col)] = state.turn
        update_frontier(state, row, col)
        if can_move(state, next_turn):
            state.turn = next_turn
        elif not can_move(state, state.turn):
                state.game_over = True
                return state
        state.possible_moves = get_possible_moves(state, state.turn)
    else:
        raise InvalidMoveException()
    return state
\end{lstlisting}

Diese Funktion überprüft für einen gegebenen Zustand
\passthrough{\lstinline!state!} ob ein Zug auf die angegebenen
Koordinaten \passthrough{\lstinline!row!} und
\passthrough{\lstinline!col!} für den Spieler
\passthrough{\lstinline!turn!} möglich ist. Das Ergebnis wird als
Wahrheitswert zurückgegeben.

\begin{lstlisting}[language=Python]
def is_move_valid(state, row, col, turn):
    dirs = [(-1,-1),(0,-1),(1,-1),(-1,0),(1,0),(-1,1),(0,1),(1,1)]
    for rowdelta, coldelta in dirs:
        try:
            if state.board[row + rowdelta, col + coldelta] == -turn and is_valid_directional_move(state, row, col, rowdelta, coldelta, turn):
                return True
        except IndexError:
            continue
    return False
\end{lstlisting}

\passthrough{\lstinline!get\_winner!} bestimmt für einen Endzustand den
Gewinner des Spiels. Gewinnt Weiß, so wird der Wert 1 zurückgegeben.
Gewinnt Schwarz, wird der Wert -1 zurückgegeben. Bei einem Unentschieden
wird der Wert 0 zurückgegeben.

\begin{lstlisting}[language=Python]
def get_winner(state):
    black_disks = count_disks(state, BLACK)
    white_disks = count_disks(state, WHITE)
    if black_disks > white_disks:
        return BLACK
    if white_disks > black_disks:
        return WHITE
    else:
        return NONE
\end{lstlisting}

Die Funktion \passthrough{\lstinline!get\_possible\_moves!} bestimmt für
einen Spielzustand \passthrough{\lstinline!state!} und den Spieler
\passthrough{\lstinline!player!} die Möglichen Züge, die der Spieler
machen kann. Die Züge werden als Liste von Koordinaten zurückgegeben.

\begin{lstlisting}[language=Python]
def get_possible_moves(state, player):
    possible_moves = []
    for (row, col) in state.frontier:
            if is_move_valid(state, row, col, player):
                possible_moves.append((row, col))
    return possible_moves
\end{lstlisting}

\passthrough{\lstinline!can\_move!} überprüft ob der Spieler
\passthrough{\lstinline!player!} im Spielzustand
\passthrough{\lstinline!state!} einen Zug machen kann und gibt das
Resultat als Wahrheitswert zurück.

\begin{lstlisting}[language=Python]
def can_move(state, player):
    return len(get_possible_moves(state, player)) != 0
\end{lstlisting}

\passthrough{\lstinline!adjacent\_opposite\_color\_directions!}
betrachtet die 8 an die gegebenen Koordinaten angrenzenden Felder. Alle
Felder die einen für den Spieler \passthrough{\lstinline!turn!}
gegnerischen Stein enthalten werden als Liste von Koordinaten
zurückgegeben.

\begin{lstlisting}[language=Python]
def adjacent_opposite_color_directions(state, row, col, turn):
    dir_list = []
    for rowdelta in range(-1, 2):
        if not 0 <= row+rowdelta < 8:
            continue
        for coldelta in range(-1, 2):
            if not 0 <= col+coldelta < 8:
                continue
            if state.board[row + rowdelta, col + coldelta] == -turn:
                dir_list.append((rowdelta, coldelta))
    return dir_list
\end{lstlisting}

Überprüft ob beim setzen eines Steins des Spielers
\passthrough{\lstinline!turn!} in das durch
\passthrough{\lstinline!row!} und \passthrough{\lstinline!col!} gegebene
Feld in die durch \passthrough{\lstinline!rowdelta!} und
\passthrough{\lstinline!coldelta!} gegebene Richtung, nach den Regeln
des Spiels Othello gegnerische Steine umgedreht werden Können.

\begin{lstlisting}[language=Python]
def is_valid_directional_move(state, row, col, rowdelta, coldelta, player):
        current_row = row + rowdelta
        current_col = col + coldelta

        last_cell_color = -player

        while True:
            if not (0 <= current_row < 8 and 0 <= current_col < 8):
                break
            if state.board[current_row, current_col] == NONE:
                break           
            if state.board[current_row, current_col] == player:
                last_cell_color = player
                break

            current_row += rowdelta
            current_col += coldelta
            
        return last_cell_color == player
\end{lstlisting}

Diese Funktion dreht im Spielzustand \passthrough{\lstinline!state!},
ausgehend von dem durch \passthrough{\lstinline!row!} und
\passthrough{\lstinline!col!} gegebenen Feld, die für den Spieler
\passthrough{\lstinline!player!} generischen Steine in die durch
\passthrough{\lstinline!rowdelta!} und
\passthrough{\lstinline!coldelta!} gegebene Richtung um.

\begin{lstlisting}[language=Python]
def convert_adjacent_cells_in_direction(state, row, col, rowdelta, coldelta, player):
    ''' If it can, converts all the adjacent/contiguous cells on a turn in
        a given direction until it finally reaches the specified cell's original color '''
    if is_valid_directional_move(state, row, col, rowdelta, coldelta, player):
        current_row = row + rowdelta
        current_col = col + coldelta
        
        while state.board[current_row, current_col] == -player:
            state.board[(current_row, current_col)] = player
            current_row += rowdelta
            current_col += coldelta
\end{lstlisting}

\passthrough{\lstinline!update\_frontier!} wird nach jedem Zug
aufgerufen um die Menge Frontier zu aktualisieren. Die durch
\passthrough{\lstinline!row!} und \passthrough{\lstinline!col!} Gegebene
Koordinate wird entfernt, während die Koordinaten von leeren umliegenden
Feldern hinzugefügt werden.

\begin{lstlisting}[language=Python]
def update_frontier(state, row, col):
        for current_row in range(row-1, row+2):
            if not 0 <= current_row < 8:
                continue
            for current_col in range(col-1, col+2):
                if not 0 <= current_col < 8:
                    continue
                if state.board[current_row, current_col] == NONE:
                    state.frontier.add((current_row, current_col))
        state.frontier.remove((row, col))
\end{lstlisting}

Die Funktion \passthrough{\lstinline!count\_disks!} zählt die Steine,
die der Spieler \passthrough{\lstinline!player!} im Spielzustand
\passthrough{\lstinline!state!} auf dem Spielfeld hat

\begin{lstlisting}[language=Python]
def count_disks(state, player):
    return numpy.count_nonzero(state.board == player)
\end{lstlisting}

\passthrough{\lstinline!get\_player\_string!} konvertiert die ID des
Spielers \passthrough{\lstinline!player!} in dessen Name. Ist
\passthrough{\lstinline!player == NONE!} so wird `Nobody' zurückgegeben.

\begin{lstlisting}[language=Python]
def get_player_string(player):
    return {BLACK: 'Black', WHITE: 'White', NONE: 'Nobody'}[player]
\end{lstlisting}
