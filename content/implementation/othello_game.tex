\begin{lstlisting}[language=Python]
%%HTML
<style>
.container { width:100% }
</style>
\end{lstlisting}

\hypertarget{implementierung-der-spiellogik}{%
\section{Implementierung der
Spiellogik}\label{implementierung-der-spiellogik}}

Im Folgenden ist das Spiel Othello implementiert. Ausgangspunkt für
diese Implementierung ist das Python Gui für Othello von Kevan Nguyen,
welches unter \url{https://github.com/kevannguyen/Othello} verfügbar
ist.

\hypertarget{importieren-der-externen-abhuxe4ngigkeiten}{%
\subsection{Importieren der externen
Abhängigkeiten}\label{importieren-der-externen-abhuxe4ngigkeiten}}

Die Implementation stützt sich für bessere Performanz auf die
Python-Bibliothek \passthrough{\lstinline!numpy!} welche unter anderem
homogene Felder und Matrizen implementiert.

\begin{lstlisting}[language=Python]
import numpy
\end{lstlisting}

\hypertarget{globale-konstanten}{%
\subsection{Globale Konstanten}\label{globale-konstanten}}

\passthrough{\lstinline!BOARD\_SIZE!} gibt die Anzahl an Zeilen und
Spalten des quadratischen Spielfelds an.

Die Konstanten \passthrough{\lstinline!BLACK!},
\passthrough{\lstinline!WHITE!} und \passthrough{\lstinline!NONE!}
werden auf die Zahlenwerte -1 , 1 und 0 abgebildet und werden für
mehrere Zwecke genutzt: - zur Repräsentation des Spielbretts - zur
Identifikation eines Spielers - zur Berechnung der Heuristiken.

\begin{lstlisting}[language=Python]
BOARD_SIZE = 8

BLACK = -1  # MINIMIZING PLAYER
WHITE = 1  # MAXIMIZING PLAYER
NONE = 0
\end{lstlisting}

\hypertarget{game-state}{%
\subsection{Game State}\label{game-state}}

Die Klasse GameState repäsentiert den Spielzustand. Dieser besteht aus
dem Spielfeld \passthrough{\lstinline!board!}, welches durch einen Numpy
Array repräsentiert wird, sowie dem Spieler
\passthrough{\lstinline!turn!}, der am Zug ist. Zusätzlich werden
weitere Informationen im Spielzustand gespeichert welche zur
Verbesserung der Performanz genutzt werden. Diese sind die im aktuellen
Spielzustand möglichen Züge, welche in der Variable
\passthrough{\lstinline!possible\_moves!} gespeichert werden. Außerdem
in der Variable \passthrough{\lstinline!frontier!} die Menge der freien
Felder, die horizontal, vertikal oder diagonal an einen Stein angrenzen.
Beim Ermitteln der möglichen Züge kann dadurch die Performanz gesteigert
werden, da nur diese Menge und nicht das gesamte Spielfeld überprüft
werden muss. Weiterhin die Anzahl an Spielsteinen auf dem Spielfeld in
der Variable \passthrough{\lstinline!num\_pieces!}. In der Variable
\passthrough{\lstinline!game\_over!}, ob der Zustand ein Endzustand ist.
Und zuletzt in der Variable \passthrough{\lstinline!last\_move!} die
Koordinaten des letzten Spielzugs. Diese Variablen werden im Laufe des
Spielverlaufs immer aktuell gehalten. Die Funktion
\passthrough{\lstinline!\_\_lt\_\_!} ist implementiert, damit
\passthrough{\lstinline!GameState!}-Objekte vergleichbar sind. Das ist
nötig, da später Tupel, die z.B. eine Priorität und einen
\passthrough{\lstinline!GameState!} enthalten, sortierbar sind.
Allerdings ist es nicht wichtig, wie die GameStates sortiert werden.

\begin{lstlisting}[language=Python]
class GameState:
    def __init__(self):
        self.board = numpy.zeros((BOARD_SIZE, BOARD_SIZE), dtype=numpy.int8)
        self.board[3, 3] = WHITE
        self.board[3, 4] = BLACK
        self.board[4, 3] = BLACK
        self.board[4, 4] = WHITE
        self.turn = BLACK
        self.possible_moves = [(2, 3), (3, 2), (4, 5), (5, 4)]
        self.frontier = {(2, 2), (2, 3), (2, 4), (2, 5),
                         (3, 2), (3, 5), (4, 2), (4, 5),
                         (5, 2), (5, 3), (5, 4), (5, 5)}
        self.num_pieces = 4
        self.game_over = False
        self.last_move = None

    def __lt__(self, other):
        return True
\end{lstlisting}

Die Liste \passthrough{\lstinline!directions!} enthält alle
horizontalen, vertikalen und diagonalen Richtungen auf dem Spielfeld als
Paar von Versätzen in Reihen- und Spaltenrichtung.

\begin{lstlisting}[language=Python]
directions = [(-1,-1),(0,-1),(1,-1),(-1,0),(1,0),(-1,1),(0,1),(1,1)]
\end{lstlisting}

Erhält die Funktion \passthrough{\lstinline!make\_move!} ein ungültigen
Spielzug, so wird eine \passthrough{\lstinline!InvalidMoveException!}
ausgelöst.

\begin{lstlisting}[language=Python]
class InvalidMoveException(Exception):
    pass
\end{lstlisting}

Die Funktion \passthrough{\lstinline!make\_move!} führt im Spielzustand
\passthrough{\lstinline!state!}, falls möglich, einen Zug auf die
Koordinaten \passthrough{\lstinline!row!} und
\passthrough{\lstinline!col!} aus.

Dazu werden zunächst alle gegnerischen Steine umgedreht, die durch den
Zug eingesperrt wurden. Wenn mindestens ein Stein umgedreht wurde, wird
\passthrough{\lstinline!disks\_flipped!} auf
\passthrough{\lstinline!True!}gesetzt. Wenn das nicht der Fall war,
handelt es sich nicht um einen gültigen Zug und es wird eine Exception
geworfen. Sonst wird der neue Stein gesetzt und im Zustand die Frontier,
der aktuelle Spieler, ob das Spiel vorbei ist und die möglichen Züge des
nächsten Spielers aktualisiert.

\begin{lstlisting}[language=Python]
def make_move(state, pos):
    if pos not in state.frontier:
        print(pos, "not in Frontier")
        raise InvalidMoveException
    disks_flipped = False
    
    (row, col) = pos
    for (row_dir, col_dir) in directions:
        if is_valid_directional_move(state, row, col, row_dir, col_dir, state.turn):
            disks_flipped = True
            flip_disks_in_direction(state, row, col, row_dir, col_dir, state.turn)

    if disks_flipped:
        state.num_pieces += 1
        state.board[pos] = state.turn
        state.last_move = pos
        update_frontier(state, row, col)
        state.turn = -state.turn
        state.possible_moves = get_possible_moves(state, state.turn)
        if len(state.possible_moves) == 0:
            state.turn = -state.turn
            state.possible_moves = get_possible_moves(state, state.turn)
            if len(state.possible_moves) == 0:
                state.game_over = True
                return state
    else:
        raise InvalidMoveException()
    return state
\end{lstlisting}

Die Funktion \passthrough{\lstinline!is\_move\_valid!} überprüft für
einen gegebenen Zustand \passthrough{\lstinline!state!}, ob ein Zug auf
die angegebenen Koordinaten \passthrough{\lstinline!row!} und
\passthrough{\lstinline!col!} für den Spieler
\passthrough{\lstinline!player!} möglich ist. Das Ergebnis wird als
Wahrheitswert zurückgegeben.

\begin{lstlisting}[language=Python]
def is_move_valid(state, row, col, player):
    for rowdelta, coldelta in directions:
        if is_valid_directional_move(state, row, col, rowdelta, coldelta, player):
            return True
    return False
\end{lstlisting}

\passthrough{\lstinline!get\_winner!} bestimmt für einen Endzustand den
Gewinner des Spiels. Gewinnt Weiß, so wird der Wert 1 zurückgegeben.
Gewinnt Schwarz, wird der Wert -1 zurückgegeben. Bei einem Unentschieden
wird der Wert 0 zurückgegeben.

\begin{lstlisting}[language=Python]
def get_winner(state):
    black_disks = count_disks(state, BLACK)
    white_disks = count_disks(state, WHITE)
    if black_disks > white_disks:
        return BLACK
    if white_disks > black_disks:
        return WHITE
    else:
        return NONE
\end{lstlisting}

Die Funktion \passthrough{\lstinline!get\_possible\_moves!} bestimmt für
einen Spielzustand \passthrough{\lstinline!state!} und den Spieler
\passthrough{\lstinline!player!} die möglichen Züge, die der Spieler
machen kann. Die Züge werden als Liste von Koordinaten zurückgegeben.

\begin{lstlisting}[language=Python]
def get_possible_moves(state, player):
    possible_moves = []
    for (row, col) in state.frontier:
        if is_move_valid(state, row, col, player):
            possible_moves.append((row, col))
    return possible_moves
\end{lstlisting}

Die Funktion \passthrough{\lstinline!is\_valid\_directional\_move!}
überprüft für einen Zustand \passthrough{\lstinline!state!} und den
Spieler \passthrough{\lstinline!player!}, ob beim Setzen eines Steins
auf die Position \passthrough{\lstinline!(row, col)!} in die durch
\passthrough{\lstinline!(rowdelta, coldelta)!} gegebene Richtung Steine
umgedreht werden können.

\begin{lstlisting}[language=Python]
def is_valid_directional_move(state, row, col, rowdelta, coldelta, player):
    current_row = row + rowdelta
    current_col = col + coldelta
    if not (0 <= current_row < 8 and 0 <= current_col < 8):
        return False
    if not state.board[current_row, current_col] == -player:
        return False
    current_row += rowdelta
    current_col += coldelta
    
    while True:
        if not (0 <= current_row < 8 and 0 <= current_col < 8):
            return False
        if state.board[current_row, current_col] == NONE:
            return False           
        if state.board[current_row, current_col] == player:
            return True
    
        current_row += rowdelta
        current_col += coldelta
\end{lstlisting}

Diese Funktion dreht im Spielzustand \passthrough{\lstinline!state!},
ausgehend von dem durch \passthrough{\lstinline!row!} und
\passthrough{\lstinline!col!} gegebenen Feld, die für den Spieler
\passthrough{\lstinline!player!} generischen Steine in die durch
\passthrough{\lstinline!rowdelta!} und
\passthrough{\lstinline!coldelta!} gegebene Richtung um.

\begin{lstlisting}[language=Python]
def flip_disks_in_direction(state, row, col, rowdelta, coldelta, player):
    current_row = row + rowdelta
    current_col = col + coldelta
    
    while state.board[current_row, current_col] == -player:
        state.board[(current_row, current_col)] = player
        current_row += rowdelta
        current_col += coldelta
\end{lstlisting}

\passthrough{\lstinline!update\_frontier!} wird nach jedem Zug
aufgerufen um die Menge Frontier zu aktualisieren. Die durch
\passthrough{\lstinline!row!} und \passthrough{\lstinline!col!} Gegebene
Koordinate wird entfernt, während die Koordinaten von leeren umliegenden
Feldern hinzugefügt werden.

\begin{lstlisting}[language=Python]
def update_frontier(state, row, col):
    for current_row in range(row-1, row+2):
        if not 0 <= current_row < 8:
            continue
        for current_col in range(col-1, col+2):
            if not 0 <= current_col < 8:
                continue
            if state.board[current_row, current_col] == NONE:
                state.frontier.add((current_row, current_col))
    state.frontier.remove((row, col))
\end{lstlisting}

Die Funktion \passthrough{\lstinline!count\_disks!} zählt die Steine,
die der Spieler \passthrough{\lstinline!player!} im Spielzustand
\passthrough{\lstinline!state!} auf dem Spielfeld hat

\begin{lstlisting}[language=Python]
def count_disks(state, player):
    return numpy.count_nonzero(state.board == player)
\end{lstlisting}

\passthrough{\lstinline!get\_player\_string!} konvertiert die ID des
Spielers \passthrough{\lstinline!player!} in dessen Name. Ist
\passthrough{\lstinline!player == NONE!} so wird `Nobody' zurückgegeben.

\begin{lstlisting}[language=Python]
def get_player_string(player):
    return {BLACK: 'Black', WHITE: 'White', NONE: 'Nobody'}[player]
\end{lstlisting}
