\begin{lstlisting}[language=Python]
%%HTML
<style>
.container { width:100% }
</style>
\end{lstlisting}

\hypertarget{implementierung-der-spiellogik}{%
\section{Implementierung der
Spiellogik}\label{implementierung-der-spiellogik}}

Im Folgenden ist die Spielelogik des Spiels Othello implementiert. Dazu
gehört die Implementation aller im \autoref{sec:spieltheorie} genannten
Aspekte, wie zum Beispiel die erzeugung eines Startzustands, sowie die
die Bestimmung und Durchführung von Spielzügen ausgehend von einem
Spielzustand. Ausgangspunkt für diese Implementierung ist das Python Gui
für Othello von Kevan Nguyen, welches unter
\url{https://github.com/kevannguyen/Othello} verfügbar ist.

\hypertarget{importieren-der-externen-abhuxe4ngigkeiten}{%
\subsection{Importieren der externen
Abhängigkeiten}\label{importieren-der-externen-abhuxe4ngigkeiten}}

Die Implementation stützt sich für bessere Performanz auf die
Python-Bibliothek \passthrough{\lstinline!numpy!}, welche unter anderem
homogene Felder und Matrizen implementiert. Eine solche Matrix wird als
interne Repräsentation des Othello Spielfeldes genutzt. Insbesondere
Operationen, die auf einen größeren Teil des Spielfeldes zugreifen
müssen werden, können dadurch beschleunigt werden.

\begin{lstlisting}[language=Python]
import numpy
\end{lstlisting}

\hypertarget{globale-konstanten}{%
\subsection{Globale Konstanten}\label{globale-konstanten}}

Im Folgenden Abschnitt werden zunächst einige Konstanten definiert,
welche in der späteren Implementation häufig genutzt werden.

Die Konstante \passthrough{\lstinline!BOARD\_SIZE!} gibt die Anzahl an
Zeilen und Spalten des quadratischen Othello Spielfelds an.
\passthrough{\lstinline!BOARD\_SIZE!} wird beispielsweise zur Iteration
über Zeilen und Spalten des Spielfeldes genutzt, sowie zur Überprüfung,
ob gegebene Koordinaten innerhalb des Spielfeldes liegen.

Die Konstanten \passthrough{\lstinline!BLACK!},
\passthrough{\lstinline!WHITE!} und \passthrough{\lstinline!NONE!}
werden auf die Zahlenwerte -1 , 1 und 0 abgebildet und werden für
mehrere Zwecke genutzt: 1. Repräsentation des Spielfeldes: Das Othello
Spielbrett wird als \(8\times 8\) Matrix von Ganzzahlen definiert,
welche jeweils einen der drei Werte annehmen können. Hierbei stehen die
Werte \passthrough{\lstinline!BLACK!} und
\passthrough{\lstinline!WHITE!} jeweils für einen Stein des jeweiligen
Spielers, während \passthrough{\lstinline!NONE!} ein leeres Feld
repräsentiert. 2. Repräsentation der Spieler:
\passthrough{\lstinline!BLACK!} und \passthrough{\lstinline!WHITE!}
werden zur Repäsentation eines Spielers genutzt. Beispielsweise enthält
der Spielzustand eine Variable \passthrough{\lstinline!turn!} die
angibt, welcher Spieler am Zug ist. 3. Berechnung der Heuristiken: Die
Werte \passthrough{\lstinline!BLACK!}, \passthrough{\lstinline!WHITE!}
und \passthrough{\lstinline!NONE!} sind so gewählt, dass sie sich für
die Berechnung der Heuristiken eignen. Der in der Künstlichen
Intelligenz maximierende Spieler hat den positiven Wert 1, während der
minimierende Spieler durch den negativen Wert -1 repräsentiert wird.
Kein Spieler, wird durch den Wert 0 dargestellt.

\begin{lstlisting}[language=Python]
BOARD_SIZE = 8

BLACK = -1  # MINIMIZING PLAYER
WHITE = 1  # MAXIMIZING PLAYER
NONE = 0 # NO PLAYER
\end{lstlisting}

\hypertarget{game-state}{%
\subsection{Game State}\label{game-state}}

Die Klasse \passthrough{\lstinline!GameState!} repäsentiert einen
Spielzustand von Othello. Dieser wird durch die im Folgenden genannten
Attribute beschrieben - Das Spielfeld \passthrough{\lstinline!board!},
welches durch eine zweidimensionale Numpy Matrix repräsentiert wird, bei
der jede Zelle die die Werte \passthrough{\lstinline!BLACK!},
\passthrough{\lstinline!WHITE!} und \passthrough{\lstinline!NONE!}
annehmen kann. - Den Spieler \passthrough{\lstinline!turn!}, der im
Spielzustand am Zug ist. Zusätzlich enthält der Spielzustand weitere
Informationen welche zur Verbesserung der Performanz genutzt werden. -
Die im aktuellen Spielzustand möglichen Züge, werden als Paare von
Koordinaten in der Variable \passthrough{\lstinline!possible\_moves!}
gespeichert werden. Ein Koordinatenpaar steht hierbei für das Setzen
eines Spielsteins auf die entsprechende Stelle auf dem Spielfeld unter
Anwendung der Othello Regeln. Diese Variable ist Teil von
\passthrough{\lstinline!GameState!} damit pro Spielzustand, die
möglichen Züge nicht mehrfach berechnet werden müssen. - Die Menge der
freien Felder, die horizontal, vertikal oder diagonal an einen Stein
angrenzen werden in der Variable \passthrough{\lstinline!frontier!}
gespeichert. Beim Ermitteln der möglichen Züge kann dadurch die
Performanz wesentlich gesteigert werden, da nur diese Menge und nicht
das gesamte Spielfeld überprüft werden muss. - Die Anzahl an
Spielsteinen auf dem Spielfeld wird in der Variable
\passthrough{\lstinline!num\_pieces!} gehalten. - Ob der Spielzustand
ein Endzustand ist, wird in der Variable
\passthrough{\lstinline!game\_over!} gespeichert. - Die Koordinaten des
letzten Spielzugs werden zur späteren Visualisierung in der Grafischen
Benutzeroberfläche in der Variable \passthrough{\lstinline!last\_move!}
gespeichert.

Die zur Performance-Verbesserung genutzen Variablen werden im Laufe des
Spielverlaufs immer aktuell gehalten.

In dem Konstruktor \passthrough{\lstinline!\_\_init\_\_!} der Klasse
\passthrough{\lstinline!GameState!} wird ein neuer Spielzustand
entsprechend den Othello Spielregeln instanziert, indem alle Variablen
entsprechen initialisiert werden.

Die Funktion \passthrough{\lstinline!\_\_lt\_\_!} ist implementiert,
damit auf \passthrough{\lstinline!GameState!}-Objekten der
Vergleichsoperator angewendet werden kann. Das ist nötig, damit in der
Künstlichen Intelligenz Tupel sortiert werden können, die beispielsweise
aus einer Priorität und einen \passthrough{\lstinline!GameState!}
bestehen. Da in diesem Fall nur die Sortierung nach der Priorität
wichtig ist, ist die implementation von
\passthrough{\lstinline!\_\_lt\_\_!} irrelevant. Daher wird, der
Einfachkeit wegen, immer True zurückgegeben.

\begin{lstlisting}[language=Python]
class GameState:
    def __init__(self):
        self.board = numpy.zeros((BOARD_SIZE, BOARD_SIZE), dtype=numpy.int8)
        self.board[3, 3] = WHITE
        self.board[3, 4] = BLACK
        self.board[4, 3] = BLACK
        self.board[4, 4] = WHITE
        self.turn = BLACK
        self.possible_moves = [(2, 3), (3, 2), (4, 5), (5, 4)]
        self.frontier = {(2, 2), (2, 3), (2, 4), (2, 5),
                         (3, 2), (3, 5), (4, 2), (4, 5),
                         (5, 2), (5, 3), (5, 4), (5, 5)}
        self.num_pieces = 4
        self.game_over = False
        self.last_move = None

    def __lt__(self, other):
        return True
\end{lstlisting}

Die Liste \passthrough{\lstinline!directions!} enthält alle
horizontalen, vertikalen und diagonalen Richtungen auf dem Spielfeld als
Zwei-Tupel. Die beiden Zahlen stellen hierbei jeweils den Versatz in
Reihen- und Spaltenrichtung dar. Diese Liste wird später in mehreren
Funktionen genutzt.

\begin{lstlisting}[language=Python]
directions = [(-1,-1),(0,-1),(1,-1),(-1,0),(1,0),(-1,1),(0,1),(1,1)]
\end{lstlisting}

Die Exception \passthrough{\lstinline!InvalidMoveException!}, wird
später in der Funktion \passthrough{\lstinline!make\_move!} geworfen,
wenn ein ungültigen Spielzug gefordert wird. Dies dient der
Fehlerbehandlung.

\begin{lstlisting}[language=Python]
class InvalidMoveException(Exception):
    pass
\end{lstlisting}

Die Funktion \passthrough{\lstinline!make\_move!} führt im Spielzustand
\passthrough{\lstinline!state!}, falls möglich, einen Zug auf die
Koordinaten \passthrough{\lstinline!row!} und
\passthrough{\lstinline!col!} aus.

Dazu werden zunächst alle gegnerischen Steine umgedreht, die durch den
Zug eingesperrt wurden. Wenn mindestens ein Stein umgedreht wurde, wird
\passthrough{\lstinline!disks\_flipped!} auf
\passthrough{\lstinline!True!}gesetzt. Wenn das nicht der Fall war,
handelt es sich nicht um einen gültigen Zug und es wird eine Exception
geworfen. Sonst wird der neue Stein gesetzt und im Zustand die Frontier,
der aktuelle Spieler, ob das Spiel vorbei ist und die möglichen Züge des
nächsten Spielers aktualisiert.

\begin{lstlisting}[language=Python]
def make_move(state, pos):
    if pos not in state.frontier:
        print(pos, "not in Frontier")
        raise InvalidMoveException
    disks_flipped = False
    
    (row, col) = pos
    board = state.board.tolist()
    for (row_dir, col_dir) in directions:
        if can_flip_in_dir(board, row, col, row_dir, col_dir, state.turn):
            disks_flipped = True
            flip_in_dir(state, row, col, row_dir, col_dir, state.turn)

    if disks_flipped:
        state.num_pieces += 1
        state.board[pos] = state.turn
        state.last_move = pos
        update_frontier(state, row, col)
        state.turn = -state.turn
        state.possible_moves = get_possible_moves(state, state.turn)
        if len(state.possible_moves) == 0:
            state.turn = -state.turn
            state.possible_moves = get_possible_moves(state, state.turn)
            if len(state.possible_moves) == 0:
                state.game_over = True
                return state
    else:
        raise InvalidMoveException()
    return state
\end{lstlisting}

Die Funktion \passthrough{\lstinline!can\_flip\_in\_dir!} überprüft für
ein Spielfeld \passthrough{\lstinline!board!} und den Spieler
\passthrough{\lstinline!player!}, ob beim Setzen eines Steins auf die
Position \passthrough{\lstinline!(row, col)!} in die durch
\passthrough{\lstinline!(rowdelta, coldelta)!} gegebene Richtung Steine
umgedreht werden können. \passthrough{\lstinline!board!} ist ein
Spielfeld als Python-Liste, da der Zugriff deutlich schneller ist, als
auf eine numpy array.

\begin{lstlisting}[language=Python]
def can_flip_in_dir(board, row, col, rowdelta, coldelta, player):
    current_row = row + rowdelta
    current_col = col + coldelta
    if not (0 <= current_row < 8 and 0 <= current_col < 8):
        return False
    if not board[current_row][current_col] == -player:
        return False
    current_row += rowdelta
    current_col += coldelta
    
    while True:
        if not (0 <= current_row < 8 and 0 <= current_col < 8):
            return False
        if board[current_row][current_col] == NONE:
            return False           
        if board[current_row][current_col] == player:
            return True
    
        current_row += rowdelta
        current_col += coldelta
\end{lstlisting}

Die Funktion \passthrough{\lstinline!is\_move\_valid!} überprüft für ein
gegebenes Spielfeld \passthrough{\lstinline!board!}, ob ein Zug auf die
angegebenen Koordinaten \passthrough{\lstinline!row!} und
\passthrough{\lstinline!col!} für den Spieler
\passthrough{\lstinline!player!} möglich ist. Das Ergebnis wird als
Wahrheitswert zurückgegeben. \passthrough{\lstinline!board!} ist hier
ebenfalls eine Python-Liste, da der Zugriff auf Elemente schneller ist,
als in einem numpy array.

\begin{lstlisting}[language=Python]
def is_move_valid(board, row, col, player):
    for rowdelta, coldelta in directions:
        if can_flip_in_dir(board, row, col, rowdelta, coldelta, player):
            return True
    return False
\end{lstlisting}

\passthrough{\lstinline!get\_utility!} bestimmt für einen Endzustand den
Gewinner des Spiels. Gewinnt Weiß, so wird der Wert 1 zurückgegeben.
Gewinnt Schwarz, wird der Wert -1 zurückgegeben. Bei einem Unentschieden
wird der Wert 0 zurückgegeben.

\begin{lstlisting}[language=Python]
def get_utility(state):
    black_disks = count_disks(state, BLACK)
    white_disks = count_disks(state, WHITE)
    if black_disks > white_disks:
        return BLACK
    if white_disks > black_disks:
        return WHITE
    else:
        return NONE
\end{lstlisting}

Die Funktion \passthrough{\lstinline!get\_possible\_moves!} bestimmt für
einen Spielzustand \passthrough{\lstinline!state!} und den Spieler
\passthrough{\lstinline!player!} die möglichen Züge, die der Spieler
machen kann. Die Züge werden als Liste von Koordinaten zurückgegeben.

\begin{lstlisting}[language=Python]
def get_possible_moves(state, player):
    board = state.board.tolist()
    possible_moves = []
    for (row, col) in state.frontier:
        if is_move_valid(board, row, col, player):
            possible_moves.append((row, col))
    return possible_moves
\end{lstlisting}

Diese Funktion dreht im Spielzustand \passthrough{\lstinline!state!},
ausgehend von dem durch \passthrough{\lstinline!row!} und
\passthrough{\lstinline!col!} gegebenen Feld, die für den Spieler
\passthrough{\lstinline!player!} generischen Steine in die durch
\passthrough{\lstinline!rowdelta!} und
\passthrough{\lstinline!coldelta!} gegebene Richtung um.

\begin{lstlisting}[language=Python]
def flip_in_dir(state, row, col, rowdelta, coldelta, player):
    current_row = row + rowdelta
    current_col = col + coldelta
    
    while state.board[current_row, current_col] == -player:
        state.board[(current_row, current_col)] = player
        current_row += rowdelta
        current_col += coldelta
\end{lstlisting}

\passthrough{\lstinline!update\_frontier!} wird nach jedem Zug
aufgerufen um die Menge Frontier zu aktualisieren. Die durch
\passthrough{\lstinline!row!} und \passthrough{\lstinline!col!} Gegebene
Koordinate wird entfernt, während die Koordinaten von leeren umliegenden
Feldern hinzugefügt werden.

\begin{lstlisting}[language=Python]
def update_frontier(state, row, col):
    for current_row in range(row-1, row+2):
        if not 0 <= current_row < 8:
            continue
        for current_col in range(col-1, col+2):
            if not 0 <= current_col < 8:
                continue
            if state.board[current_row, current_col] == NONE:
                state.frontier.add((current_row, current_col))
    state.frontier.remove((row, col))
\end{lstlisting}

Die Funktion \passthrough{\lstinline!count\_disks!} zählt die Steine,
die der Spieler \passthrough{\lstinline!player!} im Spielzustand
\passthrough{\lstinline!state!} auf dem Spielfeld hat.

\begin{lstlisting}[language=Python]
def count_disks(state, player):
    return numpy.count_nonzero(state.board == player)
\end{lstlisting}

\passthrough{\lstinline!get\_player\_string!} konvertiert die ID des
Spielers \passthrough{\lstinline!player!} in dessen Name. Ist
\passthrough{\lstinline!player == NONE!} so wird `Nobody' zurückgegeben.

\begin{lstlisting}[language=Python]
def get_player_string(player):
    return {BLACK: 'Black', WHITE: 'White', NONE: 'Nobody'}[player]
\end{lstlisting}

\passthrough{\lstinline!make\_state!} erzeugt einen Spielzustand aus dem
Spielfeld \passthrough{\lstinline!board!} und dem zu ziehenden Spieler
\passthrough{\lstinline!turn!}. Diese Funktion wird zu Testzwecken
genutzt.

\begin{lstlisting}[language=Python]
def make_state(board, turn):
    state = GameState()
    state.board = board
    state.turn = turn
    state.frontier = set()
    for row in range(8):
        for col in range(8):
            for current_row in range(row-1, row+2):
                if not 0 <= current_row < 8:
                    continue
                for current_col in range(col-1, col+2):
                    if not 0 <= current_col < 8:
                        continue
                    if state.board[current_row, current_col] == NONE:
                        state.frontier.add((current_row, current_col))
            
    state.possible_moves = get_possible_moves(state, turn)
    state.game_over = False
    if len(state.possible_moves) == 0:
        if len(get_possible_moves(state, -turn)) == 0:
            state.game_over = True
    state.num_pieces = count_disks(state, WHITE) + count_disks(state, BLACK)
    state.last_move = None
    return state
\end{lstlisting}
