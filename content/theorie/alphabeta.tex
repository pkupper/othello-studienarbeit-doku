\section{Alpha-Beta-Pruning}

Alpha-Beta-Pruning ist eine Optimierung des Minimax Algorithmus, bei der komplette Zweige des Suchbaums ausgeschlossen
werden können, die das Ergebnis des Algorithmus' nicht mehr beeinflussen können. Ein Zweig kann dann ausgeschlossen
werden, wenn für den Spieler am Zug bereits ein Zug mit einem größeren Nutzen gefunden wurde, als bei dem zu
betrachtenden Zweig maximal noch erzielbar ist.

Erreicht wird dies durch zwei Variablen $Alpha$ und $Beta$ die jeweils für den maximierenden und den minimierenden
Spieler den garantierten Nutzen repräsentieren, den diese selbst bei einem optimal spielenden Gegner erreichen können.
$Alpha$ und $Beta$ werden zu Beginn mit dem jeweils schlechtmöglichsten Nutzen initialisiert, also $Alpha = -\infty$ und
$Beta = \infty$. Die Variablen werden an die rekursiven Funktionsaufrufe weitergegeben und, falls ein besserer Zug für
einen der Spieler auftritt, aktualisiert. Ist $Beta < Alpha$, d.h. sowohl der maximierende als auch der minimierende
Spieler können bereits einen für sich jeweils besseren Zug forcieren, so muss der Zweig nicht weiter beachtet werden, da
er in einem Spiel mit optimalen Spielern nicht auftritt.

Das folgende Python Listing zeigt eine beispielhafte Implementierung des Alpha-Beta Algorithmus. Hierbei ist Weiß der
maximierende Spieler und Schwarz der minimierende Spieler. Zur Vermeidung von Redundanz wird statt zwei Funktionen $min$
und $max$ eine einzelne Funktion $alphabeta$ verwendet, in der abhängig vom aktuellen Spieler eine Fallunterscheidung
durchgeführt wird.

\lstinputlisting[language=Python]{listings/alphabeta.py}

Durch Anwendung von Alpha-Beta-Pruning wird das Ergebnis des Minimax Algorithmus' nicht beeinflusst. Jedoch kann durch
die Betrachtung einer geringeren Zahl von Knoten die Performanz signifikant verbessert werden.

Bei einer Alpha-Beta-Suche, die nicht den vollständigen Suchbaum umfasst, kann bei Verwendung einer heuristischen
Evaluations-Funktion die maximale Suchtiefe bei gleicher Rechenzeit erhöht werden, was zu einem besseren Ergebnis führt.

Da Alpha-Beta-Pruning nur dann Zweige ausschließen kann, wenn bereits bessere Zweige gefunden wurden, ist es von
Vorteil, die Zweige in der Reihenfolge absteigenden Nutzens zu betrachten. So kann die Anzahl der ausgeschlossenen
Zweige maximiert werden kann. Dies ist jedoch in der Praxis nicht optimal möglich, da dafür ja bereits eine korrekte
Bewertung der Züge stattgefunden haben muss, was die Anwendung der Alpha-Beta Suche überflüssig machen würde. Eine
ungefähre Anordnung der Züge, die dennoch zu einer wesentlichen Effizienzverbesserung führt, ist jedoch häufig möglich.
Beispielsweise können in einem primitiven Ansatz beim Schach Züge, in denen eine gegnerische Figur geschlagen wird,
priorisiert werden und bei Othello Züge in den Ecken des Spielfelds.

Um für Othello eine geeignete Reihenfolge der Züge zu berechnen, kann zunächst eine Suche mit einer geringeren Tiefe
durchgeführt werden. Diesen Ansatz macht sich "'Iterative Deepening"' zu Nutze: Begonnen wird mit einer Suchtiefe von
$d_1=1$. Das Ergebnis wird verwendet, um die Züge für eine Suche der Tiefe $d_2=d_1+1=2$ zu ordnen. Dieser Schritt wird
bis zu einer Suchtiefe $n$ wiederholt, sodass die Berechnung innerhalb von vertretbarer Zeit durchgeführt wird. Dabei
kann $n$ entweder vorher festgelegt, oder dynamisch anhand der Laufzeit ermittelt werden. Ein Vorteil von Iterative
Deepening besteht darin, dass die Ausführung jederzeit unterbrochen werden kann und der bestmögliche Zug der bisherigen
Suchtiefe bekannt ist.
\cite{alphabetaefficiency}


\ifx false
% Template for game tree
\begin{figure}[]
    \centering
    \begin{tikzpicture}[every node/.style = {regular polygon, regular polygon sides=3, draw=black}]
        \tikzset{level distance=60pt}
        \tikzset{border rotated/.style={shape border rotate=180}}
        \Tree[.A
            [.\node[border rotated]{B};
                1 2 3
            ]
            [.\node[border rotated]{C};
                x y z
            ]
            [.\node[border rotated]{D};
                a b c
            ]
        ]
    \end{tikzpicture}
    \caption{Spielbaum}
    \label{fig:game_tree}
\end{figure}
\fi

%TODO: Formalere Darstellung der Alpha Beta Suche (Mathematische Definition / evtl. Implementierung)

%TODO: Optimierung des Move Orderings durch vorherige Suche mit niedrigerer Tiefe (Neuer Abschnitt?)
