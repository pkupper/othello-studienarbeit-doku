\section{Alpha-Beta-Pruning}

Die Alpha-Beta-Pruning ist eine Optimierung des Minimax Algorithmus, bei der komplette Zweige des Suchbaums ausgeschlossen werden können, die das Ergebnis des Algorithmus' nicht mehr beeinflussen können.
Ein Zweig kann dann ausgeschlossen werden, wenn für den Spieler am Zug bereits ein Zug mit einem größeren Nutzen gefunden wurde, als bei dem zu betrachtenden Zweig maximal noch erzielbar ist.

Erreicht wird dies durch zwei variablen Alpha und Beta die jeweils für den maximierenden und den minimierenden Spieler den garantierten Nutzen repräsentieren den diese selbst bei einem optimal spielenden Gegner
erreichen können. Alpha und Beta werden zu Beginn mit dem jeweils schlechtmöglichsten Nutzen, also -Unendlich und Unendlich, initialisiert und an die rekursiven Funktionsaufrufe weitergegeben und, falls ein besserer Zug
für einen der Spieler auftaucht, aktualisiert.
Ist Beta < Alpha, d.h. sowohl der maximierende als auch der minimierende Spieler können bereits einen für sich jeweils besseren Zug forcieren, so muss der Zweig nicht weiter beachtet werden, da er bei optimalem Spiel nicht auftritt.

Durch Anwendung von Alpha-Beta-Pruning wird das Ergebnis des Minimax Algorithmus' nicht beeinflusst. Jedoch kann durch die Betrachtung einer geringeren Zahl von Knoten die Performanz signifikant verbessert werden.

Bei einer nicht vollständigen Alpha-Beta-Suche, unter Anwendung einer heuristischen Evaluations-Funktion kann gegenüber dem Minimax Algorithmus die maximale Suchtiefe bei gleicher Rechenzeit erhöht werden, was zu einem besseren Ergebnis führt.

Da Alpha-Beta-Pruning nur dann Zweige ausschließen kann, wenn bereits bessere Zweige betrachtet wurden ist es von Vorteil, die Zweige in der Reihenfolge absteigenden Nutzens zu betrachten, da so die Anzahl der ausgeschlossenen
Zweige maximiert werden kann.
Dies ist jedoch in der Praxis nicht optimal möglich, da dafür ja bereits eine korrekte Bewertung der Züge stattgefunden haben muss, was die Anwendung der Alpha-Beta Suche überflüssig macht.
Eine ungefähre Anordnung der Züge, die dennoch zu einer wesentlichen Effizienzverbesserung führt, ist jedoch häufig möglich.
Beispielsweise können in einem primitiven Ansatz beim Schach Züge, in denen eine gegnerische Figur geschlagen wird, priorisiert werden und bei Othello Züge in den Ecken des Spielfelds.

Um für Othello eine geeignete Reihenfolge der Züge zu berechnen, kann zunächst eine Suche mit einer geringeren Tiefe durchgeführt werden.
Diesen Ansatz macht sich "'Iterative Deepening"' zu Nutze:
Begonnen wird mit einer Suchtiefe von \(d_1=1\).
Das Ergebnis wird verwendet, um die Züge für eine Suche der Tiefe \(d_2=d_1+1=2\) zu ordnen.
Dieser Schritt wird bis zu einer Suchtiefe \(n\) wiederholt, sodass die Berechnung innerhalb von vertretbarer Zeit durchgeführt wird.
Dabei kann \(n\) entweder vorher festgelegt, oder dynamisch anhand der Laufzeit ermittelt werden.
\cite{alphabetaefficiency}

\ifx false
% Template for game tree
\begin{figure}[]
    \centering
    \begin{tikzpicture}[every node/.style = {regular polygon, regular polygon sides=3, draw=black}]
        \tikzset{level distance=60pt}
        \tikzset{border rotated/.style={shape border rotate=180}}
        \Tree[.A
            [.\node[border rotated]{B};
                1 2 3
            ]
            [.\node[border rotated]{C};
                x y z
            ]
            [.\node[border rotated]{D};
                a b c
            ]
        ]
    \end{tikzpicture}
    \caption{Spielbaum}
    \label{fig:game_tree}
\end{figure}
\fi

%TODO: Formalere Darstellung der Alpha Beta Suche (Mathematische Definition / evtl. Implementierung)

%TODO: Optimierung des Move Orderings durch vorherige Suche mit niedrigerer Tiefe (Neuer Abschnitt?)
