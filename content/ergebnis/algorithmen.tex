\section{Verbesserungen durch Pruning}

Um den Einfluss von AlphaBeta-Pruning, Iterative Deepening und ProbCut auf die Leistung der KI beurteilen zu können,
kann mithilfe der Funktion $debug\_num\_visited\_states$ die Zeit gemessen werden, die bei einem
gegebenen Zustand benötigt wird, um den nächsten Zug zu berechnen. Diese wurde für verschiedene Suchtiefen berechnet und
in Tabelle \ref{table:numstates} zusammengefasst. Hier ist deutlich zu erkennen, dass der AlphaBeta-Algorithmus durch
das Anwenden von Pruning im Gegensatz zum reinen MiniMax-Algorithmus vor allem für größere Suchtiefen deutlich weniger
Zeit benötigt. AlphaBeta mit Iterative Deepening hat bei geringen Suchtiefen einen relativ hohen Overhead, sodass die
Berechnung länger dauert. Ab einer Suchtiefe von sieben ist Iterative Deepening allerdings deutlich überlegen, da durch
die bessere Sortierung so viele Zweige ausgeschlossen werden können, dass trotz Overhead der nächste Zug schneller
bestimmt werden kann.
%TODO: ProbCut bringt nichts? evtl sind die Werte noch falsch

\begin{table}[hb]
\centering
\begin{tabular}{c|ccccc}
\hline
\diagbox{Suchtiefe}{KI} & MiniMax & AlphaBeta & AB\,+\,ID & ProbCut & PC\,+\,ID \\ \hline
3 & 0.11 & 0.10 & 0.14 & 0.10 & 0.14 \\
4 & 0.66 & 0.32 & 0.42 & 0.50 & 0.48 \\
5 & 4.31 & 1.51 & 1.67 & 1.68 & 2.01 \\
6 & 33.72 & 6.13 & 7.53 & 7.18 & 10.42 \\ 
7 & 273 & 22.7 & 21.9 & 27.6 & 17.8 \\
\end{tabular}
\caption{Benötigte Zeit in Sekunden für die Berechnung des nächsten Zuges}
\label{table:numstates}
\end{table}
